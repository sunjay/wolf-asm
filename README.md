# wolf-asm

[![Build Status](https://dev.azure.com/sunjayv/wolf-asm/_apis/build/status/sunjay.wolf-asm?branchName=master)](https://dev.azure.com/sunjayv/wolf-asm/_build/latest?definitionId=5&branchName=master)
[![Line Count](https://tokei.rs/b1/github/sunjay/wolf-asm)](https://github.com/sunjay/wolf-asm)

The Wolf Assembly Language is a made up assembly language for a non-existent
machine. This language was originally invented for an assembly-based puzzle game
that I was planning to create. I don't know if I'll get the chance to finish
that game anytime soon, so I thought I would release the language and VM early.

This repository contains the assembler (`./asm`) for the language and a virtual
machine (`./vm`) for interpreting the "machine code" generated by that
assembler. The assembler is designed to produce good, helpful error messages,
not just quit with some arcane error that you can't decipher. There is still a
ways to go before the messages are as good as errors produced by the Rust
compiler, but I have done quite a bit of work to setup the code so it should be
easy to keep improving the errors as I work on it.

The language is loosely based on x86, ARM, and even MIPS assembly. My goal for
the first draft was to make a language that was relatively nice to program in
and also easy to implement a VM for. [**The language documentation**][docs] is
currently in the form of some rough notes that I took while designing it. See
that document for a reference of the language syntax and supported instructions.

[docs]: ./docs.md

## Example Programs

See `asm/tests/run-pass` for several example programs written using the
language. You can also run programs in `asm/tests/ui` to see some of the error
messages.

Here is a program that outputs `hello, world!\n` and then quits:

```asm
section .code

main:
  push $fp
  mov $fp, $sp

  # Loop through and write each character

  # $8 = the address of the current character
  mov $8, message
  # $9 = the address one past the last character in the string
  load8 $9, length
  add $9, message

loop:
  cmp $8, $9
  jge end

  # Load the current character
  load1 $10, $8
  # Write the current character using memory mapped IO
  store8 0xffff_000c, $10
  # Move to the next character
  add $8, 1

  # Continue the loop
  jmp loop

end:
  pop $fp
  ret

section .static

# Declare a string with the message we want to print
message:
  .bytes 'hello, world!\n'
length:
  .b8 14
```

## Building & Running

Make sure you have [Rust](https://rustup.rs) installed.

Run the assembler using the command:

```bash
cargo run -p wolf-asm -- asm/tests/run-pass/hello.wa
```

This will generate an executable `hello` in the current directory. Note: this
executable is for the Wolf VM, not for your machine.

Run the generated machine code using the command:

```bash
cargo run -p wolf-vm -- hello
```

## Running Tests

To run tests, use the following command:

```bash
cargo test --all
```

This will run the tests for the assembler and for the VM.

To regenerate the test output files, use the command:

```bash
TESTASSEMBLER=overwrite cargo test --all
```
